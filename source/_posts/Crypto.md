---
title: Crypto
author: bellick
copyright: true
top: 0
tags:
  - crypto
categories:
  - Notebook
date: 2018-11-07 16:04:00
mathjax:
---

# chapter1

## 1. 两大类安全攻击：
	* 主动攻击：
	攻击者破坏通信过程，拦截、修改、伪造、丢弃信息、拒绝服务或假冒合法用户
	* 被动攻击：
	对传输进行窃听和监测， 通信和信息不受影响，用户感觉不到攻击存在，攻击通常是窃听或流量分析，判断通信性质。

## 2. 举例：
* 被动攻击： 
--- 消息内容的泄露
--- 流量分析
* 主动攻击：
--- 伪装
--- 重放
--- 消息修改
--- 拒绝服务
## 3. 对安全的攻击
 * Interruption：对availability的攻击
 * Interception：对confidentiality的攻击
 * Modification： 对integrity的攻击
 * Fabrication：对authenticity的攻击

# chapter2
## 1. 理论安全和实际安全
 * 理论安全（无条件安全）：
 攻击者无论接货多少密文，都无法得到足够的信息来唯一地决定明文
 * 实际安全：
 在有限的资源范围内，攻击者都不能通过系统的分析方法来破解系统。
## 2. 对称密码体制和非对称密码体制
	* 对称： 加密密钥和解密密钥相同，或者一个密钥能从另一个导出。
	* 非对称： 加密密钥和解密密钥不相同，从一个个密钥导出另一个密钥在计算上是不可行的。
## 3. 序列密码体制和分组密码体制
	* 序列： 如果密文不仅与最初给定的算法和密钥有关，同时也与明文的位置有关，则称为序列密码体制
	* 分组密码： 如果经过加密所得的密文仅与给定的算法和密钥有关，与被处理的明文数据在整个数据在整个明文中的位置无关，则称为分组密码
## 4. 确定型密码体制和概率密码体制
	* 确定型： 当明文和密钥确定了，密文也就确定了
	* 概率型： 当明文和密钥确定后，密文通过客观随机因素从一个密码集合中产生，密文形式不确定
## 5. 单向函数型密码体制和双向变换型密码体制
	* 使用如不需要解密的场合，如哈希函数
	* 双向变换型密码体制可以进行可逆的加密、解密变化。
## 6. 现代密码学的基本原则
设计加密系统时，总是假定密码算法是可以公开的，需要保密的是密钥。即Kerckhoff原则
	* 对加密系统的要求：
	1. 系统应该是实际上安全的，截获密文或已知明文-密文对时，要决定密钥或任意明文在计算上是不可行的。
	2. 加密解密算法适用于密钥空间中的所有元素
	3. 系统易于实现，使用方便
	4. 系统安全性不依赖于对加密体制或加密算法的保密，而依赖于密钥
	5. 系统的使用不应使通信网络的效率过分降低。
	
## 7. 对加密信息的攻击类型：
	1. 唯密文攻击
	2. 已知明文攻击
	3. 选择明文攻击
	4. 选择密文攻击
	5. 选择文本攻击
	
# chapter3
des 的分组和密钥分别是64位和56位的。
des 对差分分析和线性分析有一定的免疫性
#### 乘积密码的设计思想
扩散
混淆

# chapter 4

## 欧几里得算法 （EUCLID Algorithm）

数论的一个最基本的技巧是Euclid算法，求两个正整数的最大公约数 gcd(a, n), greatest common divisor
       对于任何非负的整数a和n，gcd(a, n)=gcd(n mod a, a)

假设我们有整数a,b使得d=gcd(a,b)。假设a≥b>0，现在用b
除a，由除法可得到
a=q1b+r1    0≤r1<b
如果恰巧r1=0，则b|a且d=gcd(a,b)=b。但是如果r1≠0,我们
说d|r1。这基于除法的基本性质：由d|a和d|b可以推出d|(a-
q1b)，即d|r1。现在假设有任意的整数c整除b和r1.因此
c|(q1b+r1)=a。因此c同时整除a和b，必须有c≤d，而d是a和
b的最大公因子。因此d=gcd(b,r1)

## 计算乘法逆元

  Computing multiplicative inverses
	      ax mod n = 1, x=a-1=?
    	给定a∈[0, n-1], gcd (a, n)=1，若能找到唯一整数
    x∈[0,n-1]，满足：ax mod n=1, 则称a和x互逆
	如 n=10, a=3, x=7, ax mod n=1 =3x7 mod 10
        n=17, a=5, x=7, ax mod n=1 =5x7 mod 17
	引理4.1: 如果gcd (a, n)=1, 则对于每个i, j, 0≤i<j<n,
			ai mod n≠aj mod n 
	证明：(略) 可以用反证法证明
	      此性质意味着每一个ai mod n (i=0,…,n-1)都是不同的模n剩余，而{ ai mod n }i=0,1,…,n-1是完全剩余集{0,1,…,n-1}的置换形式
	      
证明：

```
如果 ai mod n = aj mod n 
则 a(j - i) = k n
	kn mod a = 0
	
	gcd(a , n) = gcd(a mod n ,n)
```
# chapter 6
## 1.分组密码的工作模式

1. 电子密码本模式 Electronic CodeBook ECB ， 
	* 特别适合数据较少的情况，如安全传输DES密钥，
	* 一段明文消息中若有几个相同的明文组，则密文也出现几个相同的片段
	* 对于很长的消息，ECB是不安全的。如果消息是非结构化的，密码分析可能李彤其结构特征来破解
	* ECB的弱点来源于其加密过的密文分组是相互独立的
2. 密文分组链接模式 Cipher Block Chaining CBC 
	* 加密输入是当前明文分组和前一密文分组的异或，形成一条链，使用不同的密钥，这样每个明文分组的加密函数输入与明文分组之间不再有固定的关系。
	* 每个密文分组依赖于所有明文分组
	* 明文消息中的任何一点变化都会影响所有密文分组
	* 发送方和接收方共享的初始向量 Initial Value（IV）是一个固定值，或者必须哟昂ECB方式在消息之前加密传送
	* 在消息的最后，还要处理不够长度的分组
	
3. 密码反馈模式 Cipher FeedBack （CFB）
	* 是一种将 DES转化成流密码的技术，不在要求报文被填充成整个分组，可以实时运行，如果要传输一个字符流，每个字符都可以使用面向字符的流密码加密后立即传输
	* 加密:加密函数的输入是个64位的移位集村子，产生初始向量 IV 。加密函数高端j位与明文P1的第一单元异或，产生 j 位密文C1进入移位寄存器低端，继续加密，与P2异或，如此重复
	* 解密：采用相同的方案，但是使用加密函数而非解密函数。
	* 当数据以位或字节形式到达时使用都是适当的
	* 最通用的是流密码形式
	* 如果传输中有比特差错，那么比特差错会一直传播下去
4. 输出反馈模式 Output FeedBack OFB
	* 结构上类似CFB，但是OFB中加密函数输出被反馈回移位寄存器，CFB中是密文单元被反馈回移位寄存器。
	* 优点是传输中的比特差错不会传播，
	* 缺点是比CFB更容易受报文流篡改攻击。即密文中的某位取反，恢复出的明文相应也取反
5. 计算器模式 Counter CRT
	* 与OFB很像，但是加密的是计数器的值而不是任何反馈回来的值
	* 每个明文分组都必须使用一个不同的密钥和计数器值，决不要重复使用
	* 可以用于高速网络加密中

# chapter 8
1. Format 's Thoerem
2. Euler 's Thoerem
3. Chinese Remainder Thoerem
4. 孙子定理

# chapter 9

## 1. 对称密码体制的问题

	* 加密能力和解密能力是捆绑在一起的
	* 密钥更换、传递和交换需要可靠信道，密钥分发困难
	* 如果有N个用户， 则需要 C= N(N-1)/2个密钥，密钥管理困难
	* 无法满足不相识的人之间通信的保密要求
	* 不能实现数字签名
## 2. 非对称密码体制的基本特点
	* 加密能力和解密能力是分开的
	* 密钥分发简单
	* 需要保存的密钥量大大减少，N个用户只需要N个密钥
	* 课满足不相识的人之间的保密通信
	* 可以实现数字签名
## 3. 公钥算法依赖于一个加密秘钥和一个与之相关的不同的解密密钥，算法有如下特点：
	* 仅根基密码算法和加密密钥来确定解密密钥在计算上是不可行的
	* 两个密钥的任何一个都可用来加密，另一个用来解密
## 4. 公钥密码体制的组成：
	* 明文：算法的输入，可读信息或数据
	* 加密算法：对明文进行各种转换
	* 公钥和私钥：算法的输入，分别用于加密和解密
	* 密文：算法的输出
	* 解密算法：根据密文和密钥，还原明文。
## 5. 公钥密码体制的应用：
	* 加密/解密：发送方用接收方的公钥对消息解密
	* 数字签名：发送方用起私钥对消息签名，可以对整体消息签名或对消息的摘要签名。
	* 密钥交换：通信双方交换会话密钥
	
## 6. 公钥密码的分析
	* 公钥密码易受穷举攻击，解决方法是使用长密钥；同时为了便于加密和解密，有希望密钥足够段，目前仅限于密钥管理和签名。
	* 找出一种从给定的公钥计算出私钥是第二种方法，尚未在数学上证明对一特定公钥算法这种攻击是不可行的。
	* 穷举攻击是第三种攻击方式，攻击者用公钥对所有可能的消息加密，并与传送的密文匹配，从而解密任何消息；抵抗的方法是要在发送的消息后加入随机数
	
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
## 7. RSA密码体制
	* 随机选择两个秘密大素数 p 和 q
	* 计算公开模数 n = p* q
	* 计算密码的欧拉指数函数 \\(\psi(n) = (p-1)(q-1)\\)
	* 选择一个与\\(\psi(n)\\)互素的数，作为 e 或 d
	* 用 Euclid 算法计算 \\(\psi(n)\\)的乘法逆元素，及根据 \\(ed mod \psi(n)=1\\),求 d 或 e
	* 加密： \\(C = M^e mod n\\)
	* 解密 \\( M = C^d mod n = (M^e mod n)^d mod n = M\\)
	* 这里 \\(\psi(n)\\) 为欧拉函数。
## 8. 有三种可能的对RSA的攻击方法
	* 强行攻击： 尝试所有可能的密钥
	* 数学攻击： 对两个素数成绩的因子分解
	* 计时攻击：依赖于解密算法的运行时间

# chapter10 
## 1. 几种公钥分配方法： 
	* 公开发布
	* 公开可访问的目录
	* 公钥授权
	* 公钥证书

## 2. 公开可访问的目录：
	* 一旦攻击者获得目录管理员私钥，则可传递伪造的公钥，可以假冒任何通信方以窃取消息，或者修改已有的记录
	
## 3. 公钥授权
	* A发送带有时间戳的消息给公钥管理员, 请求B的当前公钥
	* 管理员给A发送用其私钥KRauth加密的消息, A用管理员的公钥解密，可以确信该消息来自管理员：
		1.  B的公钥KUb，用来加密；
		2. 原始请求，A可以验证其请求未被修改；
		3. 原始时间戳, A可以确定收到的不是来自管理员的旧消息。
	* A保存B的公钥, 并用它对包含A的标识IDA和Nonce1的消息加密, 然后发送给B
	* B以同样方式从管理员处得到A的公钥
B用KUa对A的N1和B的N2加密, 发送给A
	* A用B的公钥对N2加密并发送给B, 使B相信其通信伙伴是A

 ![PKA](https://ws4.sinaimg.cn/large/006tNbRwly1fwozqvz3rcj30fa0bjjs2.jpg)
## 4. 公钥证书
![CA](https://ws2.sinaimg.cn/large/006tNbRwly1fwozqkokhaj30fw0b23z1.jpg)
	* 有了公钥证书使得不通过实时访问公钥授权部门而实现公钥交换成为可能
	* 公钥证书将一个通信方的身份与他的公开密钥绑定在于一起，通常还包括有效期和使用方法等。
	* 证书的所有内容必须经由可信公钥授权方或公钥授权方签名后方可生效
	* 知道公钥授权当局公开密钥的任何一个人都可以验证一个用户的公开密钥证书的有效性
	* 对于申请者A，管理员提供的证书为：
\\(C_a= E_KRauth[T,ID_A,KUa]\\)

## 5. 利用公钥密码分配传统密码体制的密钥
	* 一种简单的密钥分配方法：
		![](https://ws3.sinaimg.cn/large/006tNbRwly1fwozpqy4i2j30f405q74g.jpg)	
	* 这个协议不安全，会受到中间人攻击
	* Diffle-Hellman 密钥交换：
	![](https://ws1.sinaimg.cn/large/006tNbRwly1fwp0b2pi45j30k40f0mzf.jpg)
		1. 是一种公钥分发机制，不是用来加密的
		2. 安全性依赖于求解离散对数问题
		3. 不能抵抗中间人攻击

## 6. 基于DLP的概率密码系统 EIGamal Cryptosystem
	![](https://ws3.sinaimg.cn/large/006tNbRwly1fwp0905x4yj30k30f3goc.jpg)
	
# chapter 11

## 1. 报文认证：
	* 保护消息的完整性
	* 验证发起方身份
	* 消息源的不可否认
## 2. 三种消息认证的方法
	* 消息加密
	* 消息认证码（MAC）
	* 哈希函数
## 3. 可能有下述攻击：
	* 泄密：将消息透露给没有合法身份的第三方
	* 传输分析：分析双方通信模式
	* 伪装： 欺诈源向网络中插入一条消息
	* 内容篡改： 对消息内容的修改
	* 顺序篡改： 对消息顺序的修改
	* 计时篡改： 对消息的延时和重放
	* 信源抵赖： 发送方否认发送过某消息
	* 信宿抵赖： 接收方否认接收过某消息
## 4. 公钥加密作为认证手段
	* 发送方用私钥加密信息，再用接收方的公钥加密，就实现了既保密又认证的通信。
	* 代价是要执行四次复杂的公钥算法
	
## 5. 消息认证码 MAC
	* 使用密钥产生短小的定长数据分组，即所欲为的密码校验MAC，将他附加在报文汇中。通信双反A和B共享密钥K，A计算 \\(MAC = C_K(M)\\),附在报文后发给B，B接收到报文后重新计算MAC，并与收到的MAC比较，如果只有收发双方知道密钥且两个MAC匹配，则：
		* 接收方可以确信报文未被更改
		* 接收方可以确信报文来自声称的发送者
		* 接收方可以确信报文序号正确，如果有的话
	* 报文认证不提供加密
	* MAC函数类似加密，但非数字签名，也无需可逆
	* 将MAC直接与明文并置，然后加密传输比较常用
	* MAC不提供数字签名，因为双方共享密钥
## 6. 散列函数 Hash Function
	* 一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)，作为输出，亦称作报文摘要Message Digest. 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变
	* 不同的散列码使用方式
## 7. 散列函数
	* 一个散列函数以变长的报文M作为输入，产生定长的散列码H(M)，作为输出，亦称作报文摘要Message Digest. 散列码是报文所有比特的函数值，具有差错检测能力，报文任意一比特的改变都将引起散列码的改变。 h=H(M)
	* 报文摘要的基本原理
对任意长度的明文m，经由哈希函数(杂凑函数)h产生固定长度的哈希值h(m)，用来对明文作鉴别(authentication)或数字签名(digital signature)。哈希函数值是对明文的一种“指纹”(finger print)或是摘要(digest)。对哈希函数值的数字签名，就是对此明文的数字签名，可以用来提高数字签名的效率
## 8. 对散列函数的要求 \\(h=H(M)\\)
	1. H 可以应用于任意大小的数据块
	2. H 可产生固定长度的输出
	* 对任意给定的明文x，计算H(x)容易，可由硬件或软件实现
	* 对任意给定的散列码h，找到满足H(x)=h的x，在计算上不可行，单向性
	* 对任何给定的分组x，找到满足y≠x且H(x)=H(y)的y，在计算上不可行，抗弱碰撞性
	* 找到任何满足H(x)=H(y)的偶对(x, y)，在计算上不可行，抗强碰撞性
## 9. 强哈希函数
	* 条件6主要用于防范所谓的生日攻击法
	* 能满足条件1-5的，称为弱哈希函数(Weak Hash Function)
	* 能同时满足条件6的，称为强哈希函数(Strong Hash Function)
	* 应用在数字签名上的哈希函数必须是强哈希函数

# chapter13
## 1. 数字签名： 数字签名是使以数字形式存储的明文信息经过特定密码变化生成密文，作为相应的明文的签名，使明文信息接受者能够验证信息确实来自合法用户，以及确认信息发送者身份。
## 2. 对数字签名的基本要求：
	* 在收发双方不能完全信任的情况下，需要除认证之外的其他方法来解决假冒和否认问题，数字签名则是解决方法
	* 签名接受者能容易地验证签字这对信息所做的数字签名，包括日期和时间
	* 任何人，包括签名接收者，都不能伪造签名者的签字。
	* 发生争议时，可由第三方解决。
## 3. 数字签名和消息认证的区别：
	* 消息认证是使消息接收方验证消息发送者发送的内容有无被修改过，防止第三方破坏，但收发双方有利害冲突时，就无法解决纷争，需要更严格的手段，即数字签名
## 4. 数字签名的基本形式

	1. 对消息签名的两种方法：
		* 对消息整体签字
		* 对消息摘要签字
	2. 两类数字签名
		* 确定性数字签名，明文与签名一一对应。
		* 概率性数字签名，一个明文可有多个合法签名，每次都不一样

## 5. 认证协议
	* 认证服务和功能：
		1. 消息的真实性
		2. 存储数据的真实性
		3. 接收方提供回执
		4. 发送方不可否认
		5. 时效性和公证可能性
	* 认证的目的： 防窃听、防假冒或拦截、防窃取等
## 6. 基本认证方法
	* 单向认证： 
	* 双向认证
	* 可信中继
	* 群认证
## 7. 对称加密方法：
	* 使用两层传统加密密钥结构来保证愤愤不环境中通信的保密性
	* 通常需要可信密钥分发中心 KDC Key Distribution Center
		* 每一方与KDC共享主密钥
		* KDC产生双方通信要用的会话密钥
		* 用主密钥来分发会话密钥
## 8. EIGamal 数字签名方法
![](https://ws1.sinaimg.cn/large/006tNbRwly1fwqbm6d20ej30j80ejdhs.jpg)
![](https://ws4.sinaimg.cn/large/006tNbRwly1fwqbmmg5w9j30j906q3zi.jpg)

# chapter 14
## 1. Kerberos 
	* 通过提供一个集中的授权服务器来负责用户对服务器的认证和服务器对用户的认证，而不是对每个服务器提供详细的认证协议
		1. 允许用户通过网络访问分布的服务器
		2. 不需要信任所有的工作站和服务器
		3. 只要信任集中式的认证服务器即可
	* Kerberos仅依赖于对称加密体制而未使用公钥体制
	* Kerberos 为保护用户信息和服务器资源，要求用户想服务器提供身份认证，服务器向客户提供身份认证
	* Kerberos 体系结构为分布的 客户/ 服务器 结构，并拥有一个或多个 Kerberos服务器提供认证服务
	* Kerberos 需求：
		1. Security： 网络监听不能通过冒充其他用户获得有用的消息
		2. Reliability：高可靠性，且使用分布式服务结构
		3. Transparency：用户除了要输入口令，不需要知道认证的发生
		4. Scalability： 能支持大量客户端和服务器，模块化、分布式体系结构
	* Kerberos实现时采用的是基于 Needham-Schroeder 的认证协议
	* 方法： 使用中央式的识别服务器(Authentication Server, AS),为用户和应用服务器提供识别服务。AS与用户共享口令，与其他服务器共享密钥，在注册时以特别安全的方式分配给各方。

## 2. 一个简单的认证会话
![](https://ws4.sinaimg.cn/large/006tNbRwly1fwr7pvcwwvj30xa0p0afg.jpg)
## 3. 一个更安全的认证会话交互过程
![](https://ws2.sinaimg.cn/large/006tNbRwly1fwr82lninaj30xd0p0afw.jpg)
![](https://ws1.sinaimg.cn/large/006tNbRwly1fwr82xrinmj30xe0p0aev.jpg)
![](https://ws4.sinaimg.cn/large/006tNbRwly1fwr8336vajj30xb0p0n1z.jpg)